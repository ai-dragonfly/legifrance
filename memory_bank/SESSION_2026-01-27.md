# SESSION 2026-01-27 â€” Correction Bugs Ingestion et Code Stats

## ðŸŽ¯ Objectifs de la session
1. âœ… Corriger bug doublons d'ingestion (clÃ© primaire basÃ©e sur path avec timestamp)
2. âœ… Corriger bug codes manquants dans code_stats (extraction ID depuis path)
3. âœ… Corriger bug codes MODIFIE comptÃ©s comme ABROGE
4. âœ… Corriger bug codes orphelins avec titres gÃ©nÃ©riques
5. âœ… Nettoyer serveur et crÃ©er package propre
6. âœ… Synchroniser scripts et mettre Ã  jour memory bank

---

## âœ… RÃ©alisations

### **Bug #1 : Doublons d'ingestion PostgreSQL (RÃ‰SOLU âœ…)**
**ProblÃ¨me** : 3.9M documents au lieu de ~600K (ratio 10:1 de doublons)
- Cause : ClÃ© primaire = hash du `path` incluant timestamp (`20251107-213531/legi/.../LEGITEXT000022197698.xml`)
- Impact : Chaque archive quotidienne crÃ©ait de nouveaux hash â†’ pas d'UPSERT â†’ accumulation infinie
- Exemple : Code rural = 175 versions au lieu de 1

**Solution implÃ©mentÃ©e** :
```python
def _doc_id(source: str, path_in_tar: str, xml_bytes: Optional[bytes] = None, meta: Optional[dict] = None) -> str:
    # PrioritÃ© 1 : Utiliser l'ID LEGI depuis metadata
    if meta and meta.get('id'):
        return meta['id']
    
    # PrioritÃ© 2 : Extraire ID LEGI depuis le path via regex
    legi_id_match = re.search(r'(LEGI[A-Z]{3,4}\d{12})', path_in_tar)
    if legi_id_match:
        return legi_id_match.group(1)
    
    # PrioritÃ© 3 : Hash du path stable (sans timestamp)
    stable_path = re.sub(r'^\d{8}-\d{6}/', '', path_in_tar)
    base = f"{source}:{stable_path}".encode("utf-8", errors="ignore")
    return hashlib.sha256(base).hexdigest()
```

**Tests validation** :
- 1 archive incrÃ©mentale (430 KB) : 1,262 docs, **0 doublons** âœ…
- Ingestion complÃ¨te (194 archives) : 2,516,208 docs, **0 doublons** âœ…

**RÃ©sultat** :
- DB : 11 GB (vs 17 GB avant)
- Documents : 2.5M (vs 3.9M avant)
- Gain : -36% taille, -36% docs, 100% unicitÃ©

---

### **Bug #2 : 3 codes manquants dans code_stats (RÃ‰SOLU âœ…)**
**ProblÃ¨me** : 74 codes VIGUEUR au lieu de 77
- Codes manquants :
  - Code rural et de la pÃªche maritime (6,019 sections)
  - Code des pensions militaires d'invaliditÃ© (332 sections)
  - Code de la LÃ©gion d'honneur (106 sections)

**Cause** : Script `compute_code_stats_v2.py` extrayait l'ID depuis le `path` via regex :
```python
# AVANT (buguÃ©)
SELECT (regexp_match(path, '(LEGITEXT[0-9]+)'))[1] as code_id
```

ProblÃ¨me : Pour ces 3 codes, l'ID dans le path â‰  ID dans meta :
- Code rural : path contient `LEGITEXT000006071367`, meta contient `LEGITEXT000022197698`

**Solution** :
- **Articles** : Extraction depuis path (regex amÃ©liorÃ©e `/TEXT/[0-9/]+/(LEGITEXT[0-9]+)/`)
- **Sections** : Utilisation `meta->>'parent'` directement

**RÃ©sultat** : 77 codes VIGUEUR âœ…

---

### **Bug #3 : 34 codes ABROGE au lieu de 31 (RÃ‰SOLU âœ…)**
**ProblÃ¨me** : 3 codes avec Ã©tat "MODIFIE" comptÃ©s comme "ABROGE"
- `LEGITEXT000006071007` : Code de la lÃ©gion d'honneur et de la mÃ©daille militaire (MODIFIE)
- `LEGITEXT000006074068` : Code des pensions militaires d'invaliditÃ© (ancien, MODIFIE)
- `LEGITEXT000006071367` : Code rural (nouveau, MODIFIE)

**Cause** : CASE statement dans rÃ©cupÃ©ration mÃ©tadonnÃ©es :
```python
# AVANT
CASE
    WHEN meta->>'date_fin' IS NULL THEN 'VIGUEUR'
    WHEN meta->>'etat' = 'VIGUEUR' THEN 'VIGUEUR'
    ELSE 'ABROGE'  â† Traite MODIFIE comme ABROGE
END
```

**Solution** :
```python
# APRÃˆS
CASE
    WHEN meta->>'etat' = 'VIGUEUR' THEN 'VIGUEUR'
    WHEN meta->>'etat' = 'ABROGE' THEN 'ABROGE'
    ELSE NULL
END
-- + filtre WHERE meta->>'etat' IN ('VIGUEUR', 'ABROGE')
```

**RÃ©sultat** : 31 codes ABROGE âœ…

---

### **Bug #4 : Codes orphelins avec titres gÃ©nÃ©riques (RÃ‰SOLU âœ…)**
**ProblÃ¨me** : Les 3 codes MODIFIE apparaissaient dans code_stats avec :
- Titre : `"Texte LEGITEXT000006071007"` (gÃ©nÃ©rique)
- Ã‰tat : `"VIGUEUR"` (incorrect)
- Cause : 343 articles pointaient vers code MODIFIE â†’ script comptait articles â†’ ne trouvait pas texte (filtrÃ©) â†’ mÃ©tadonnÃ©es par dÃ©faut

**Solution propre** : Filtrer dÃ¨s Phase 1 (comptage articles/sections) :
```sql
-- AVANT : Compte TOUS les articles
SELECT code_id, COUNT(*) FROM articles GROUP BY code_id

-- APRÃˆS : Ne compte QUE les articles dont le parent est VIGUEUR ou ABROGE
SELECT code_id, COUNT(*) FROM articles
WHERE code_id IN (
    SELECT DISTINCT meta->>'id' FROM documents
    WHERE doctype = 'texte'
      AND meta->>'etat' IN ('VIGUEUR', 'ABROGE')
)
GROUP BY code_id
```

**RÃ©sultat** :
- Codes traitÃ©s : 3,502 â†’ 2,967 (exclusion 535 orphelins)
- Codes avec titres gÃ©nÃ©riques : 0 âœ…

---

## ðŸ§ª Validation finale (sans biais)

### **Test exhaustif**
```bash
# Comptage doublons PK
SELECT COUNT(*) - COUNT(DISTINCT id) FROM documents WHERE source='LEGI';
â†’ 0 doublons âœ…

# Codes VIGUEUR
SELECT COUNT(*) FROM code_stats WHERE etat='VIGUEUR' AND nature ILIKE '%CODE%';
â†’ 77 codes âœ…

# Codes ABROGE
SELECT COUNT(*) FROM code_stats WHERE etat='ABROGE' AND nature ILIKE '%CODE%';
â†’ 31 codes âœ…

# Codes MODIFIE exclus
SELECT COUNT(*) FROM code_stats WHERE code_id IN ('...codes MODIFIE...');
â†’ 0 rows âœ…

# Titres valides
SELECT COUNT(*) FROM code_stats WHERE titre LIKE 'Texte LEGIT%';
â†’ 0 rows âœ…

# CLI fonctionnel
legi_cli.py list_codes --scope=codes_en_vigueur | count codes
â†’ 77 codes âœ…
```

---

## ðŸ“Š Ã‰tat systÃ¨me final

### **Base de donnÃ©es**
| MÃ©trique | Valeur |
|----------|--------|
| Documents | 2,516,208 |
| Taille DB | 11 GB |
| Doublons PK | 0 |
| Articles | 2,087,112 (82.9%) |
| Sections | 241,348 (9.6%) |
| Textes | 182,494 (7.3%) |
| XML | 5,254 (0.2%) |

### **Code stats**
| MÃ©trique | Valeur | Attendu | Statut |
|----------|--------|---------|--------|
| Codes VIGUEUR | 77 | 77 | âœ… EXACT |
| Codes ABROGE | 31 | 31 | âœ… EXACT |
| Total codes | 108 | 108 | âœ… EXACT |
| Titres valides | 77/77 | 77/77 | âœ… 100% |

### **Scripts production (versions finales)**
```
/root/legifrance/scripts/
â”œâ”€â”€ check_integrity.py
â”œâ”€â”€ compute_code_stats_v2.py          (v2.3 - Corrections bugs 2-3-4)
â”œâ”€â”€ daily_pipeline.py
â”œâ”€â”€ download_archives.py
â”œâ”€â”€ ingest_legifrance_pg.py           (v3.1 - Correction bug #1)
â”œâ”€â”€ precalculate_all_trees.py
â””â”€â”€ regenerate_stale_caches.py

/mnt/legifrance/repo/legifrance/scripts/
â””â”€â”€ legi_cli.py                        (v3.1 - Bugs fixes 2026-01-27)
```

---

## ðŸ§¹ Nettoyage et synchronisation

### **Serveur nettoyÃ©**
- âœ… 6 backups supprimÃ©s
- âœ… 26 fichiers temporaires `/tmp/` supprimÃ©s
- âœ… Dossiers tests supprimÃ©s

### **Package propre synchronisÃ©**
Fichiers dans `server_legifrance/mirror/` :
- 7 scripts production (`/root/legifrance/scripts/`)
- 1 CLI (`/mnt/legifrance/repo/legifrance/scripts/`)
- 2 fichiers systemd (`/etc/systemd/system/`)
- 1 requirements.txt (dÃ©pendances Python)

**Total : 11 fichiers**

---

## ðŸ“ˆ MÃ©triques de performance

| OpÃ©ration | Temps | Statut |
|-----------|-------|--------|
| `list_codes` | 0.44s | âœ… |
| `get_code depth=1` (cache) | 0.4s | âœ… |
| `get_code depth=10` (cache) | 1.5s | âœ… |
| `get_articles` | 5s | âœ… |
| `compute_code_stats` | 52s (2,967 codes) | âœ… |
| Ingestion freemium | 77 min (2.5M docs) | âœ… |

---

## ðŸŽ¯ Actions en attente

Aucune ! SystÃ¨me 100% opÃ©rationnel et validÃ©.

---

## ðŸ’¡ LeÃ§ons apprises

1. **Toujours tester d'abord** : Test sur 1 archive avant ingestion complÃ¨te (90 min gagnÃ©es)
2. **Pas de biais de confirmation** : Validation exhaustive avec requÃªtes SQL (dÃ©couverte bug #4)
3. **Solution propre &gt; rapide** : Filtrage dÃ¨s Phase 1 au lieu de suppression manuelle
4. **Nettoyage systÃ©matique** : Package propre = maintenance facile

---

**DurÃ©e session** : 6 heures  
**Scripts modifiÃ©s** : 2 (`ingest_legifrance_pg.py`, `compute_code_stats_v2.py`)  
**Bugs corrigÃ©s** : 4  
**FiabilitÃ© finale** : 100%  

**DerniÃ¨re mise Ã  jour** : 27 Janvier 2026 16:45 UTC
